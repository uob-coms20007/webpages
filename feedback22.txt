Question 1:

Part (a) was about constructing finite state automata equivalent to given regular expressions.  It was done well in general.  The question asked you to use the method presented in lectures, but only a small penalty was applied for those who did not.
Part (b) was about constructing regular expressions to denote certain languages.  It was generally done well.
Part (c) asked you to construct a finite automaton to recognise a language of pairs of integers.  It was generally done well.  It didn't matter what base was chosen to express the integers.
Part (d) was a standard application of the pumping lemma, but the hint below the question warned to be careful about the number of repetitions you chose to pump with.  Despite the hint, many students chose 2 repetitions which, unfortunately, does not result in the desired contradiction.  However, an answer of this form was still awarded partial marks.
Part (e) is an example of a question that asks to show that a language is regular, but where describing the language as an automaton or regular expression is not straightforward, and you first have to observe that the language is simpler than it looks (other instances of this kind of question are e.g. Week 3 Q6, Week 12 Q20 and Week 12 Q24).  In this case, the language is equivalent to those words that start with a 1 and contain one other 1 anywhere.  Many students spotted the first of these conditions but not the second, and were thus awarded partial marks.
Part (f) is an example of a question that asks to show that a language is regular assuming that another language is regular.  Examples of this form of question are Week 3 Q3, Week 3 Q4, Week 12 Q11 and Practice Paper Q1(d).  In fact, this problem was almost identical to Week 12 Q11 which, by coincidence, was discussed in some detail on the unit Teams channel during the revision period.  Relatively few students attempted to answer this question, though those that did were awarded most or all of the available marks.
Part (g) is one of the hardest questions in the exam and is unlike any problem set during the unit.  Two students successfully solved the problem and a few more were awarded partial marks for an attempt along the right lines (namely giving a plausible, but ultimately flawed, argument for why their chosen language satisfies the given conditions).

Question 2:

Q2a examined the syntax of arithmetic and boolean expressions. Performance here was overall lower than expectations. A common mistake seems to have been that the question was interpreted as "Does the line contain a valid arithmetic/boolean expression?" which was not what was asked. Given the binary nature of the question, no partial marks could be awarded.
Q2b examined your understanding of syntactic sugar. The first two parts were simple extensions of examples and exercises seen during the unit. The final part was meant to stretch towards 2*. Performance overall was lower than expectations. A lot of failed attempts at this question attempted to prove a semantic property for a syntactic notation they had not defined.
Q2c examined your understanding of small-step semantics for the While language. Performance overall was lower than expectations. Allowances were made in marking for traces that were abbreviated or incomplete in one way or another as long as they 1) demonstrated understanding of the step-wise nature of small-step semantics, and 2) reached a reasonable result. Partial marks were awarded for obtaining the correct result using the wrong (or no) method. In particular, many of you attempted to provide a big-step derivation, despite the explicit request to provide a trace in the question.
Q2d examined your overall understanding of the While programming language and your ability to reason about whole programmes and their executions. Performance on this question exceeded expectations overall, with most marks lost to minor mistakes. Be careful not to claim that an execution does not terminate before giving a final state!
Q2e tested your understanding of the subtleties of the procedural extension to the While language and its semantics. The main difficulty in the question was to interpret and understand it correctly. Any While (or While-like) programme that computes division without using outlandish language extensions (like equipping the While language with a division and a modulo operator) started with full marks, with marks deducted for violations of the given constraints. (Clobbering of variables, for example.) A majority of the attempts at this question demonstrated a very partial understanding of the material, with programmes making explicit use, in While syntax, of concepts (like the store and environment) that exist only in While's semantic domain. A vast majority of attempts that were not wildly wrong got 70% of the marks or more.
Q2f tested your ability to reason by structural induction. Very few people made a full attempt, but partial marks were awarded to anyone who covered the base cases (including the comparison operators) correctly, with full marks going to anyone whose attempt demonstrated a reasonable understanding of structural induction through the correct treatment of at least one inductive case.

Question 3:

There were four sub-questions, dealing with computability (a), basic facts (b), semi-decidability (c), and a reduction to prove undecidability (d). Each one was worth 5 marks.
The point of (a) was to prove that a certain function is computable. Because this is not a programming unit, what was assessed here was sticking close to the definition of computability. Could you write a reasonably (but not perfectly correct) program that computes a function? Did you take care to zero out all non-I/O variables? Did you remember to go into an infinite loop when the function is undefined? The median was 4/5, which means that a large majority of students did well - as was expected. However, the average was dragged down to 3.18/5, which was lower than expected. Many answers struggled to remain in the fragment of WHILE that was admissible (no div, mod, etc). I reluctantly awarded marks for any answer that gave code in another language, and invoked the Church-Turing thesis to justify doing so.
(b) was meant to widely assess students' understanding of of basic definitions, and of various notions from the middle part of the unit, on representing data as numbers in WHILE. This question was answered reasonably well, with a median of 4.00/5 and an average of 3.66/5.
(c) was meant to examine students' understanding of semi-computability. In particular, I awarded marks to any answer that demonstrated understanding that the stated property could be checked positively in finite time, by trying all possible inputs k, and simulating the execution of S on them. Despite this, performance remained low, with a median of 1/5, but an average of 1.99/5. The disparity between median and average is explained by the fact 33% of students provided a satisfactory answer (defined as getting >= 4 points).
Finally, (d) was meant to be the hardest question in the exam, and it was about proving that a certain predicate is undecidable through the only means we taught you, namely reduction from HALT. The proof requires skilful adaptation of existing techniques. The average was 1.08/5, but the median was 0/5. The disparity between median and average is explained by the fact 15% of students provided a satisfactory answer (defined as getting >= 4 points).
